\begin{problem}
    除了FCFS之外, 没有一个硬盘调度算法是完全公平的(即可能发生饥饿现象).
    \begin{question}
        解释为什么这个断言成立.
    \begin{answer}
        因为除了FCFS之外其他所有算法的调度中, 最先请求的柱面都有可能
        不是最先被处理的, 请求会被阻塞, 如果一直阻塞就会产生饥饿现象.
    \end{answer}
    \end{question}

    \begin{question}
        对诸如SCAN的调度算法进行改进, 以保证公平性.
        \begin{answer}
            采用``老化(aging)''技术, 即一个请求在一定时间未被处理后
            优先级将会被强制提前.
        \end{answer}
    \end{question}

    \begin{question}
        解释为什么在分时系统中公平性是一个重要的指标.
        \begin{answer}
            需要保证每一个请求都要得到处理, 不能让任何一个请求等待过久.
        \end{answer}
    \end{question}

    \begin{question}
        有些情况下操作系统不公平地处理I/O请求很重要, 举出三个以上这样的例子.
        \begin{answer}
            \begin{itemize}
                \item 内存的分页与换页应当优先于用户请求.
                \item 内核请求优先于用户请求.
                \item 对于内存的操作优先于对于文件系统的操作.
            \end{itemize}
        \end{answer}
    \end{question}
\end{problem}

\begin{problem}
    假设一个硬盘有5000个柱面, 编号为0至4999.
    驱动器目前在柱面143处理请求, 而且上一个请求经常在柱面125处理.
    等待中的请求队列按照FIFO的顺序是:
    \[86,1470,913,1774,948,1509,1022,1750,130\]
    从目前磁头位置开始, 对于以下每种算法, 磁头处理所有请求经过的
    总距离是多少?
    \begin{itemize}
        \item FCFS
        \item SSTF
        \item SCAN
        \item LOOK
        \item C-SCAN
    \end{itemize}

\begin{answer}
    对于FCFS算法, 处理顺序为:
    \[143,86,1470,913,1774,948,1509,1022,1750,130\]
    计算得出总距离为7081.

    对于SSTF算法, 处理顺序为:
    \[143,130,86,913,948,1022,1470,1509,1750,1774\]
    计算得出总距离为1745.

    对于以下的算法, 可以知道现在磁头读取方向为从小编号到大编号.

    对于SCAN算法, 顺序为:
    \[143,913,948,1022,1470,1509,1750,1774,4999,130,86\]
    计算得出总距离为9749.

    对于LOOK算法, 顺序为:
    \[143,913,948,1022,1470,1509,1750,1774,130,86\]
    计算得出总距离为3319.

    对于C-SCAN算法, 顺序为:
    \[143,913,948,1022,1470,1509,1750,1774,4999,0,130,86\]
    计算得出总距离为9813.


\end{answer}

\end{problem}